/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package ece651.sp22.grp8.risk.client;

import ece651.sp22.grp8.risk.*;
import ece651.sp22.grp8.risk.Map;

import java.io.*;
import java.net.Socket;
import java.net.SocketException;
import java.util.*;

public class ClientApp {
  private final Socket client;
  public ClientGame game;
  protected final BufferedReader inputReader;
  private final PrintStream out;
  public final Utility utility;
  private ArrayList<Long> myGames;

  public ClientApp(String host, int port, BufferedReader inputReader, PrintStream out) throws IOException {
    this.client = new Socket(host, port);
    this.utility = new Utility(client);
    this.game = new ClientGame();
    this.inputReader = inputReader;
    this.out = out;
  }

  public static void main(String[] args) {
    try {
      BufferedReader input = new BufferedReader(new InputStreamReader(System.in));
      ClientApp app = new ClientApp(args[0], Integer.parseInt(args[1]), input, System.out);
      // ClientApp app = new ClientApp("127.0.0.1", Integer.parseInt(args[1]), input,
      // System.out);
      Runtime.getRuntime().addShutdownHook(new Thread() {
        public void run() {
          try {
            Thread.sleep(200);
            System.out.println("Shutting down ...");
            throw new SocketException();
          } catch (Exception e) {
            Thread.currentThread().interrupt();
          }
        }
      });
      app.start();
    } catch (Exception e) {
      System.out.print("Client closed: \n" + e + "\n");
    }
  }

  public void start() throws IOException {
    // out.print(utility.recvMsg(client));// print greetings
    setupPhase();// set the player, game and map
    setInitialize();
    String gameStatus = null;
    // String gameStatus = actionPhase();// CONTINUE
    if (gameStatus.equals("LOSE")) {
      losePhase();
    } else if (gameStatus.equals("END")) {
      out.print(GamePrompt.LOSE);
      showGameResult();
    } else {
      out.print(GamePrompt.WIN);
      showGameResult();
    }
  }

  public String showGameResult() {
    String result = utility.recvMsg();
    return result;
  }

  /**
   * This player has lost, it can either watch or disconnect
   */
  protected void losePhase() throws IOException {
    while (true) {
      out.print(GamePrompt.LOSE + GamePrompt.LOSECHOICE);
      String response = inputReader.readLine();
      if (response.equalsIgnoreCase("C")) {
        out.print(GamePrompt.WATCHGREETING);
        utility.sendPacket(new LeavePacket(new Leave(game.getPlayerID(), false)));
        Leave leave;
        while (true) {
          leave = (Leave) utility.recvPacket().getObject();
          if (!leave.getLeave()) {
            setMap(); // get map
          } else {
            break;
          }
        }
        showGameResult();
        return;
      } else if (response.equalsIgnoreCase("D")) {
        out.print(GamePrompt.GOODBYE);
        utility.sendPacket(new LeavePacket(new Leave(game.getPlayerID(), true)));
        return;
      } else {
        out.print(GamePrompt.UNRECOGNIZED);
      }
    }
  }

  /**
   * This phase assign this client a player, a game and a map
   * 
   * @throws IOException
   */
  public void setupPhase() throws IOException {
    // setPlayer();
    setGames();
    out.print("Waiting for other players join the game...\n");
    setMap();
    game.setInitialPara();
  }

  public void setInitialPara() {
    game.setInitialPara();
  }

  /**
   * This method receives the game map from the server,
   */

  public void setMap() throws IOException {
    MapPacket mp = (MapPacket) utility.recvPacket();
    Map map = mp.getObject();
    game.setMapAndView(map);
  }

  /**
   * this method update level, food resource and tech resource at the beginning of
   * each turn
   */
  public void updatePlayer() throws IOException {
    PlayerPacket pp = (PlayerPacket) utility.recvPacket();
    Player p = pp.getObject();
    game.setPlayer(p);
  }

  /**
   * This method sends a specific request to the server to get and store a player
   * object as a response.
   * 
   * @return true if login successfully
   */
  public String login(String username, String password) {
    utility.sendMsg(GamePrompt.LOGIN);
    utility.sendMsg(username);
    utility.sendMsg(password);
    String response = utility.recvMsg();
    if (response.equals(GamePrompt.OK)) {
      long playerID = Long.parseLong(utility.recvMsg());
      game.setPlayerID(playerID);
      out.print("Your player ID is " + playerID + ".\n");
    }
    return response;
  }

  public String register(String username, String password) {
    utility.sendMsg(GamePrompt.REGISTER);
    utility.sendMsg(username);
    utility.sendMsg(password);
    String response = utility.recvMsg();
    if (response.equals(GamePrompt.OK)) {
      long playerID = Long.parseLong(utility.recvMsg());
      game.setPlayerID(playerID);
      out.print("Your player ID is " + playerID + ".\n");
    }
    return response;
  }

  /**
   * This is a helper method for setGame(), it sends a request about creating a
   * new game with specific players to the server
   * 
   * @throws IOException
   */
    public void createGame(String number) throws IOException {
    this.utility.sendMsg(GamePrompt.NEWGAME);
    this.utility.sendMsg(String.valueOf(number));
    long gameID = Integer.parseInt(Objects.requireNonNull(utility.recvMsg()));
    out.print("Your create a game whose ID is " + gameID + ".\n");
    game.setGameID(gameID);
  }

  public ArrayList<Long> getMyGames() {
    return myGames;
  }

  /**
   * Get all games created by everyone
   * @return
   * @throws IOException
   */
  public ArrayList<Long> getAllGames() throws IOException {
    GalleryGames gg = (GalleryGames) utility.recvPacket().getObject();
    HashMap<Long,ArrayList<Long>> games= gg.getGames();
    Set<Long> gameSet = new HashSet<>(); //reduce duplicated games
    for(ArrayList<Long> gameIDArr : games.values()){
      gameSet.addAll(gameIDArr);
    }
    myGames = games.get(game.getPlayerID());
    ArrayList<Long> gamesArr = new ArrayList<>(gameSet.size());
    gamesArr.addAll(gameSet);
    return  gamesArr;
  }

  /**
   * A helper function to join a game
   * 
   * @param gameID is the game ID
   * @return true if join successfully
   */
  public String joinGame(String gameID) {
    this.utility.sendMsg(gameID);
    String response = this.utility.recvMsg();
    if (response.equals(GamePrompt.REJOIN)||response.equals(GamePrompt.NEWGAME)) {
      game.setGameID(Long.parseLong(gameID));
    }
    return response;
  }

  /**
   * This method sets this player a game
   */
  private void setGames() {
    while (true) {
      try {
        out.print("Player " + game.getPlayerID() + ", Which game would you like to join? Please enter the game ID.\n"
            + "If you want to create a new game, please enter C(reate).\n");
        String text = inputReader.readLine();
        if (text.equalsIgnoreCase("C")) {
          createGame("2");
        } else { // join an existing game
          if (joinGame(text).equals(GamePrompt.REJOIN)||
                  joinGame(text).equals(GamePrompt.NEWGAME)) {
            return;
          }
        }
      } catch (NumberFormatException e) {
        out.print(GamePrompt.UNRECOGNIZED);
      } catch (IOException e) {
        out.print(e);
      }
    }
  }

  // functions for initializing units
  public int getRemainUnits() {
    return game.remainUnits;
  }

  public Territory getNextTerritory() {
    if (game.currTerri.size() != 0) {
      return game.currTerri.get(0);
    } else {
      return null;
    }
  }

  public String initialUnits(Territory territory, int remainUnits, int num) {
    return game.initialUnitsOnce(territory, remainUnits, num);
  }

  public void setInitialize() throws IOException {
    utility.sendPacket(game.packInitializeUnits());
    out.print("Wait for other players...\n");
    setMap();// get a whole map after all player finished this phase
  }

  // functions for play one turn
  /**
   * play one turn
   * 
   * @return the result of action
   * @throws IOException
   */
  public String playOneTurn(String choice, AbstractAction abstractAction) throws IOException {
    // for move
    if (choice.equals("M")) {
      utility.sendPacket(new MovePacket((Move) abstractAction));
      String invalid = utility.recvMsg();
      int cost = Integer.parseInt(utility.recvMsg());
      if (invalid.equals(GamePrompt.OK)) {
        game.handleMove((Move) abstractAction, cost);
      }
      return invalid;
    }
    // for attack
    else if (choice.equals("A")) {
      utility.sendPacket(new AttackPacket((Attack) abstractAction));
      String invalid = utility.recvMsg();
      if (invalid.equals(GamePrompt.OK)) {
        game.handleAttack((Attack) abstractAction);
      }
      return invalid;
    }
    // for upgrade tech level
    else if (choice.equals("UT")) {
      utility.sendPacket(new UpTechPacket((UpTech) abstractAction));
      String invalid = utility.recvMsg();
      if (invalid.equals(GamePrompt.OK)) {
        game.handleUT();
      }
      return invalid;
    }
    // for upgrade unit
    else {
      utility.sendPacket(new UpUnitPacket((UpUnit) abstractAction));
      String invalid = utility.recvMsg();
      if (invalid.equals(GamePrompt.OK)) {
        game.handleUU((UpUnit) abstractAction);
      }
      return invalid;
    }
  }

  public int getPlayerNum() {
    return game.getPlayerNum();
  }

  /**
   * handle commit for this turn
   * 
   * @return the status after this turn
   * @throws IOException
   */
  public ActionResult handleCommit() throws IOException {
    // send to server
    utility.sendPacket(game.doCommit());
    // clear the local attack info this turn
    game.attackOneTurn.clear();
    // receive server's handle results
    ActionResultPacket aRP = (ActionResultPacket) utility.recvPacket();
    ActionResult aR = aRP.getObject();
    return aR;
  }

  public Player getPlayer() {
    return game.getPlayer();
  }

  public Map getMap() {
    return game.getMap();
  }

  public String getAttackInfo() {
    return game.printAttackInfo();
  }

  public String getResult(ActionResult ar) {
    return game.printResult(ar);
  }

  /**
   * play one turn until it is committed
   * 
   * @return game status : continue, win, lose, end
   * @throws IOException
   */
  // public String playOneTurnPhase() throws IOException {
  // // display the whole of all players' information
  // setMap();
  // updatePlayer();
  // out.print(game.getMapTextView());
  // // play one turn
  // boolean end = playOneTurn();
  // while (!end) {
  // end = playOneTurn();
  // }
  // out.print("Waiting for other players place action orders...\n");
  // // display attack result of this turn
  // ActionResultPacket aRP = (ActionResultPacket) utility.recvPacket();
  // ActionResult aR = aRP.getObject();
  // String result = game.printResult(aR);
  // if (result != null) {
  // out.print(result);
  // }
  // return aR.getGameStatus();
  // }

  /**
   * play all turns until the player lose the game
   * 
   * @return game status: continue, win, lose, end
   * @throws IOException
   */
  // protected String actionPhase() throws IOException {
  // String gameStatus = "CONTINUE";
  // while (gameStatus.equals("CONTINUE")) {
  // gameStatus = playOneTurnPhase();
  // return gameStatus;
  // }
}
